# Code Generation Phases

This project uses a multi-phase code generation strategy to maintain type safety across the stack. All generation is driven by Go struct definitions as the single source of truth.

## Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                    Source of Truth                               │
│                                                                  │
│  internal/service/types.go                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  type LayerConfig struct {                              │   │
│  │      ID       string  `json:"id"`                       │   │
│  │      Name     string  `json:"name" signal:"newlayer"`   │   │
│  │      File     string  `json:"file" signal:"newlayer"`   │   │
│  │      Opacity  float64 `json:"opacity" signal:"newlayer"`│   │
│  │  }                                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
          ┌───────────────────┼───────────────────┐
          ▼                   ▼                   ▼
    ┌──────────┐        ┌──────────┐        ┌──────────┐
    │ Phase 1  │        │ Phase 2  │        │ Phase 3  │
    │ Signals  │        │ OpenAPI  │        │ TypeScript│
    └────┬─────┘        └────┬─────┘        └────┬─────┘
         │                   │                   │
         ▼                   ▼                   ▼
   signals_gen.go      openapi.json          api.ts
```

## Phase 1: Signal Generation

**Purpose**: Generate type-safe parsers for Datastar signals

**Source**: `internal/gen/signals/main.go`

**Output**: `internal/api/editor/signals_gen.go`

### What It Does

Reads Go structs and generates:

1. **Signal name constants** - Maps field names to signal names
2. **Parse functions** - Converts JSON signals to typed structs
3. **Reset functions** - Returns default values for form clearing

### Example

Given this struct:

```go
// internal/service/types.go
type LayerConfig struct {
    ID       string  `json:"id"`
    Name     string  `json:"name"`
    File     string  `json:"file"`
    GeomType string  `json:"geomType"`
    Opacity  float64 `json:"opacity"`
}
```

The generator produces:

```go
// internal/api/editor/signals_gen.go
// Code generated by go run ./internal/gen/signals. DO NOT EDIT.

package editor

import "github.com/joeblew999/plat-geo/internal/service"

// LayerConfigSignalNames maps struct fields to signal names
var LayerConfigSignalNames = struct {
    Name     string
    File     string
    GeomType string
    Opacity  string
}{
    Name:     "newlayername",
    File:     "newlayerfile",
    GeomType: "newlayergeomtype",
    Opacity:  "newlayeropacity",
}

// ParseLayerConfigSignals converts Datastar signals to LayerConfig
func ParseLayerConfigSignals(s Signals) service.LayerConfig {
    return service.LayerConfig{
        Name:     s.String("newlayername"),
        File:     s.String("newlayerfile"),
        GeomType: s.String("newlayergeomtype"),
        Opacity:  s.Float("newlayeropacity"),
    }
}

// ResetLayerConfigSignals returns default signal values for form reset
func ResetLayerConfigSignals() map[string]any {
    return map[string]any{
        "newlayername":     "",
        "newlayerfile":     "",
        "newlayergeomtype": "polygon",
        "newlayeropacity":  1.0,
    }
}
```

### Running Phase 1

```bash
# Via Taskfile
task gen:signals

# Directly
go run ./internal/gen/signals
```

### Signal Naming Convention

The generator uses this pattern:
- Prefix: `new` + lowercase struct name (e.g., `newlayer`)
- Suffix: lowercase field name (e.g., `name`)
- Result: `newlayername`

This keeps signals predictable and collision-free.

## Phase 2: OpenAPI Generation

**Purpose**: Generate OpenAPI 3.1 spec from Huma routes

**Source**: Huma framework (automatic)

**Output**: `openapi.json` / `openapi.yaml`

### What It Does

Huma reads your route definitions and generates:

1. **Paths** - All endpoints with methods
2. **Schemas** - Request/response types from Go structs
3. **Validation** - Constraints from struct tags
4. **Documentation** - Descriptions from `doc:` tags

### Example

This Go code:

```go
type CreateLayerInput struct {
    Body struct {
        Name     string  `json:"name" minLength:"1" maxLength:"100" doc:"Layer name"`
        Opacity  float64 `json:"opacity" minimum:"0" maximum:"1" default:"1" doc:"Layer opacity"`
    }
}

huma.Post(api, "/api/v1/layers", createLayer)
```

Generates this OpenAPI:

```yaml
paths:
  /api/v1/layers:
    post:
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                name:
                  type: string
                  minLength: 1
                  maxLength: 100
                  description: Layer name
                opacity:
                  type: number
                  minimum: 0
                  maximum: 1
                  default: 1
                  description: Layer opacity
```

### Running Phase 2

```bash
# Via Taskfile
task huma:spec

# Via CLI
go run ./cmd/geo spec --output openapi.json

# YAML format
go run ./cmd/geo spec --format yaml --output openapi.yaml
```

## Phase 3: TypeScript Generation

**Purpose**: Generate TypeScript types from OpenAPI spec

**Source**: `openapi.json` (from Phase 2)

**Output**: `web/src/generated/api.ts`

### What It Does

Uses `openapi-typescript` to generate:

1. **Type definitions** - All request/response types
2. **Path types** - Type-safe route definitions
3. **Component schemas** - Reusable type definitions

### Example

From OpenAPI:

```yaml
components:
  schemas:
    LayerConfig:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        opacity:
          type: number
```

Generates TypeScript:

```typescript
// web/src/generated/api.ts
export interface components {
  schemas: {
    LayerConfig: {
      id?: string;
      name?: string;
      opacity?: number;
    };
  };
}
```

### Running Phase 3

```bash
# Via Taskfile
task huma:ts

# Directly (requires openapi-typescript)
npx openapi-typescript openapi.json -o web/src/generated/api.ts
```

## Complete Generation Pipeline

### All Phases

```bash
# Run all generation phases
task gen
```

This runs:
1. `task gen:signals` - Phase 1
2. `task huma:spec` - Phase 2
3. `task huma:ts` - Phase 3

### Taskfile Configuration

```yaml
# Taskfile.yml
tasks:
  gen:
    desc: Run all code generation
    cmds:
      - task: gen:signals
      - task: huma:spec
      - task: huma:ts

  gen:signals:
    desc: Generate signal parsers
    sources:
      - internal/service/types.go
    generates:
      - internal/api/editor/signals_gen.go
    cmds:
      - go run ./internal/gen/signals

  huma:spec:
    desc: Export OpenAPI spec
    sources:
      - internal/api/**/*.go
    generates:
      - openapi.json
    cmds:
      - go run ./cmd/geo spec --output openapi.json

  huma:ts:
    desc: Generate TypeScript types
    sources:
      - openapi.json
    generates:
      - web/src/generated/api.ts
    cmds:
      - npx openapi-typescript openapi.json -o web/src/generated/api.ts
```

## Development Workflow

### Hot Reload with Generation

```bash
# Runs air with auto-regeneration
task dev
```

Air configuration (`.air.toml`):
```toml
[build]
  cmd = "task gen && go build -o ./tmp/main ./cmd/geo"
  bin = "./tmp/main serve"
  include_ext = ["go", "html"]
```

### Watch Mode

```bash
# Watch for changes and regenerate
task huma:watch
```

## When to Regenerate

| Change | Regenerate |
|--------|------------|
| Add/remove struct field | `task gen` (all phases) |
| Change field type | `task gen` (all phases) |
| Add new route | `task huma:spec` + `task huma:ts` |
| Change validation tags | `task huma:spec` + `task huma:ts` |
| Change signal prefix | `task gen:signals` |

## Generator Source Code

The signal generator is in [internal/gen/signals/main.go](../internal/gen/signals/main.go):

```go
package main

import (
    "os"
    "text/template"
)

func main() {
    // Read struct definitions (could use go/ast for real parsing)
    // Generate signals_gen.go using template

    tmpl := template.Must(template.New("signals").Parse(signalsTemplate))

    f, _ := os.Create("internal/api/editor/signals_gen.go")
    defer f.Close()

    tmpl.Execute(f, templateData{
        Package: "editor",
        Structs: []structInfo{
            {Name: "LayerConfig", Fields: layerFields},
            // ... more structs
        },
    })
}
```

## Best Practices

1. **Never edit `*_gen.go` files** - They're overwritten on regeneration
2. **Run `task gen` after struct changes** - Keep everything in sync
3. **Commit generated files** - Makes CI builds faster
4. **Use `task dev` for development** - Auto-regenerates on save
5. **Check generated output** - Verify signal names match HTML bindings

## Troubleshooting

### Signal mismatch errors

```
Error: signal 'newlayername' not found
```

Fix: Run `task gen:signals` and verify HTML `data-bind` matches generated names.

### OpenAPI spec outdated

```
TypeScript error: Property 'newField' does not exist
```

Fix: Run `task huma:spec && task huma:ts` to regenerate types.

### Generator fails

```
Error: cannot find package "internal/service"
```

Fix: Run from project root directory, not from `internal/gen/signals/`.
