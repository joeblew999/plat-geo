// Command gen produces Datastar codegen artifacts from Go struct tags.
//
// Usage:
//
//	go run ./cmd/gen
//
// Reads struct tags (doc, default, enum, required, minimum, maximum,
// signal, input, sse) and generates:
//   - internal/api/editor/signals_gen.go
//   - web/templates/generated/layer-form-gen.html
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"reflect"
	"strings"
	"text/template"

	"github.com/joeblew999/plat-geo/internal/service"
)

// Registration: struct type + signal prefix. Everything else comes from tags.
var structs = []struct {
	Name   string
	Type   reflect.Type
	Prefix string
}{
	{"LayerConfig", reflect.TypeOf(service.LayerConfig{}), "newlayer"},
}

type Field struct {
	Name       string
	Signal     string
	GoType     string
	ResetGo    string // Go literal
	ResetPlain string // plain string
	Label      string
	InputType  string // text | number | checkbox | color | select | sse
	Required   bool
	Min, Max   string
	Step       string
	Enum       []string
	SSEURL     string
	SSEID      string
}

func resolve(t reflect.Type, prefix string) []Field {
	var out []Field
	for i := range t.NumField() {
		sf := t.Field(i)

		goType := sf.Type.Kind().String()
		if goType == "float32" {
			goType = "float64"
		}
		// Auto-skip non-primitive fields (slices, structs, etc.)
		if goType != "string" && goType != "float64" && goType != "bool" && goType != "int" {
			continue
		}
		// Auto-skip ID fields
		if sf.Name == "ID" {
			continue
		}

		// Signal name from tag or lowercase field name
		suffix := strings.ToLower(sf.Name)
		if sig := sf.Tag.Get("signal"); sig != "" {
			suffix = sig
		}

		// Reset/default from tag
		def := sf.Tag.Get("default")

		goReset := `""`
		switch goType {
		case "float64":
			goReset = "0"
		case "bool":
			goReset = "false"
		case "int":
			goReset = "0"
		}
		if def != "" {
			switch goType {
			case "string":
				goReset = fmt.Sprintf("%q", def)
			default:
				goReset = def
			}
		}

		// Input type: from `input` tag, `enum` tag, or Go type
		inputType := sf.Tag.Get("input")
		var enum []string
		var sseURL, sseID string

		if inputType == "" {
			if enumTag := sf.Tag.Get("enum"); enumTag != "" {
				inputType = "select"
				enum = strings.Split(enumTag, ",")
			} else {
				switch goType {
				case "float64", "int":
					inputType = "number"
				case "bool":
					inputType = "checkbox"
				default:
					inputType = "text"
				}
			}
		}

		if inputType == "sse" {
			if tag := sf.Tag.Get("sse"); tag != "" {
				parts := strings.SplitN(tag, ",", 2)
				sseURL = parts[0]
				if len(parts) > 1 {
					sseID = parts[1]
				}
			}
		}

		label := sf.Tag.Get("doc")
		if label == "" {
			label = sf.Name
		}

		step := ""
		if goType == "float64" {
			step = "0.1"
		}

		out = append(out, Field{
			Name:       sf.Name,
			Signal:     prefix + suffix,
			GoType:     goType,
			ResetGo:    goReset,
			ResetPlain: def,
			Label:      label,
			InputType:  inputType,
			Required:   sf.Tag.Get("required") == "true",
			Min:        sf.Tag.Get("minimum"),
			Max:        sf.Tag.Get("maximum"),
			Step:       step,
			Enum:       enum,
			SSEURL:     sseURL,
			SSEID:      sseID,
		})
	}
	return out
}

// --- templates ---

var signalsTmpl = template.Must(template.New("signals").Parse(`// Code generated by go run ./cmd/gen; DO NOT EDIT.

package editor

import (
	"github.com/joeblew999/plat-geo/internal/service"
)
{{range .}}
var {{.Name}}SignalNames = struct {
{{- range .Fields}}
	{{.Name}} string
{{- end}}
}{
{{- range .Fields}}
	{{.Name}}: "{{.Signal}}",
{{- end}}
}

func Parse{{.Name}}Signals(s Signals) service.{{.Name}} {
	return service.{{.Name}}{
{{- range .Fields}}
	{{- if eq .GoType "string"}}
		{{.Name}}: s.String("{{.Signal}}"),
	{{- else if eq .GoType "float64"}}
		{{.Name}}: s.Float("{{.Signal}}"),
	{{- else if eq .GoType "bool"}}
		{{.Name}}: s.Bool("{{.Signal}}"),
	{{- else if eq .GoType "int"}}
		{{.Name}}: s.Int("{{.Signal}}"),
	{{- end}}
{{- end}}
	}
}

func Reset{{.Name}}Signals() map[string]any {
	return map[string]any{
{{- range .Fields}}
		"{{.Signal}}": {{.ResetGo}},
{{- end}}
	}
}
{{end}}
`))

var htmlTmpl = template.Must(template.New("html").Parse(
	`{{"{{"}}/* Code generated by go run ./cmd/gen; DO NOT EDIT. */{{"}}"}}
{{"{{"}}define "layer-form"{{"}}"}}
{{- range .Fields}}
<div class="form-group">
{{- if eq .InputType "checkbox"}}
    <label><input type="checkbox" data-bind:{{.Signal}}> {{.Label}}</label>
{{- else if eq .InputType "sse"}}
    <label>{{.Label}}</label>
    <select data-bind:{{.Signal}}{{if .Required}} required{{end}} id="{{.SSEID}}">
        <option value="">Loading...</option>
    </select>
{{- else if eq .InputType "select"}}
    <label>{{.Label}}</label>
    <select data-bind:{{.Signal}}{{if .Required}} required{{end}}>
{{- range .Enum}}
        <option value="{{.}}">{{.}}</option>
{{- end}}
    </select>
{{- else if eq .InputType "color"}}
    <label>{{.Label}}</label>
    <div class="color-group">
        <input type="color" data-bind:{{.Signal}}>
        <input type="text" data-bind:{{.Signal}} placeholder="{{.ResetPlain}}">
    </div>
{{- else}}
    <label>{{.Label}}</label>
    <input type="{{.InputType}}" data-bind:{{.Signal}}{{if .Required}} required{{end}}{{if .Min}} min="{{.Min}}"{{end}}{{if .Max}} max="{{.Max}}"{{end}}{{if .Step}} step="{{.Step}}"{{end}}{{if .ResetPlain}} placeholder="{{.ResetPlain}}"{{end}}>
{{- end}}
</div>
{{- end}}
{{"{{"}}end{{"}}"}}
`))

type data struct {
	Name   string
	Fields []Field
}

func main() {
	var all []data
	for _, s := range structs {
		all = append(all, data{Name: s.Name, Fields: resolve(s.Type, s.Prefix)})
	}

	// Go signals
	var buf bytes.Buffer
	if err := signalsTmpl.Execute(&buf, all); err != nil {
		fatal("signals template: %v", err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fatal("gofmt: %v\n%s", err, buf.String())
	}
	writeFile("internal/api/editor/signals_gen.go", formatted)

	// HTML form
	buf.Reset()
	if err := htmlTmpl.Execute(&buf, all[0]); err != nil {
		fatal("html template: %v", err)
	}
	writeFile("web/templates/generated/layer-form-gen.html", buf.Bytes())
}

func writeFile(path string, d []byte) {
	if err := os.WriteFile(path, d, 0644); err != nil {
		fatal("write %s: %v", path, err)
	}
	fmt.Printf("Generated %s\n", path)
}

func fatal(f string, args ...any) {
	fmt.Fprintf(os.Stderr, f+"\n", args...)
	os.Exit(1)
}
