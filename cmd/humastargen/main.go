// Command humastargen produces Datastar codegen artifacts from Go struct tags.
//
// Usage:
//
//	go run ./cmd/humastargen
//
// Reads struct tags (doc, default, enum, required, minimum, maximum,
// signal, input, sse) and generates:
//   - internal/api/editor/signals_gen.go
//   - web/templates/generated/layer-form-gen.html
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"reflect"
	"strings"
	"text/template"

	"github.com/joeblew999/plat-geo/internal/service"
)

// Registration: struct type + output metadata. Everything else comes from tags.
var structs = []struct {
	Name     string
	Type     reflect.Type
	Prefix   string // Datastar signal prefix
	FormTmpl string // HTML template define name
	GoPkg    string // output Go package name
	GoOut    string // output .go file path
	HTMLOut  string // output .html file path
}{
	{
		Name: "LayerConfig", Type: reflect.TypeOf(service.LayerConfig{}),
		Prefix: "newlayer", FormTmpl: "layer-form", GoPkg: "editor",
		GoOut:  "internal/api/editor/signals_gen.go",
		HTMLOut: "web/templates/generated/layer-form-gen.html",
	},
}

type Field struct {
	Name       string
	Signal     string
	GoType     string
	ResetGo    string // Go literal
	ResetPlain string // plain string
	Label      string
	InputType  string // text | number | checkbox | color | select | sse
	Required   bool
	Min, Max   string
	Step       string
	Enum       []string
	SSEURL     string
	SSEID      string
}

func resolve(t reflect.Type, prefix string) []Field {
	var out []Field
	for i := range t.NumField() {
		sf := t.Field(i)

		goType := sf.Type.Kind().String()
		if goType == "float32" {
			goType = "float64"
		}
		// Auto-skip non-primitive fields (slices, structs, etc.)
		if goType != "string" && goType != "float64" && goType != "bool" && goType != "int" {
			continue
		}
		// Auto-skip ID fields
		if sf.Name == "ID" {
			continue
		}

		// Signal name from tag or lowercase field name
		suffix := strings.ToLower(sf.Name)
		if sig := sf.Tag.Get("signal"); sig != "" {
			suffix = sig
		}

		// Reset/default from tag
		def := sf.Tag.Get("default")

		goReset := `""`
		switch goType {
		case "float64":
			goReset = "0"
		case "bool":
			goReset = "false"
		case "int":
			goReset = "0"
		}
		if def != "" {
			switch goType {
			case "string":
				goReset = fmt.Sprintf("%q", def)
			default:
				goReset = def
			}
		}

		// Input type: from `input` tag, `enum` tag, or Go type
		inputType := sf.Tag.Get("input")
		var enum []string
		var sseURL, sseID string

		if inputType == "" {
			if enumTag := sf.Tag.Get("enum"); enumTag != "" {
				inputType = "select"
				enum = strings.Split(enumTag, ",")
			} else {
				switch goType {
				case "float64", "int":
					inputType = "number"
				case "bool":
					inputType = "checkbox"
				default:
					inputType = "text"
				}
			}
		}

		if inputType == "sse" {
			if tag := sf.Tag.Get("sse"); tag != "" {
				parts := strings.SplitN(tag, ",", 2)
				sseURL = parts[0]
				if len(parts) > 1 {
					sseID = parts[1]
				}
			}
		}

		label := sf.Tag.Get("doc")
		if label == "" {
			label = sf.Name
		}

		step := ""
		if goType == "float64" {
			step = "0.1"
		}

		out = append(out, Field{
			Name:       sf.Name,
			Signal:     prefix + suffix,
			GoType:     goType,
			ResetGo:    goReset,
			ResetPlain: def,
			Label:      label,
			InputType:  inputType,
			Required:   sf.Tag.Get("required") == "true",
			Min:        sf.Tag.Get("minimum"),
			Max:        sf.Tag.Get("maximum"),
			Step:       step,
			Enum:       enum,
			SSEURL:     sseURL,
			SSEID:      sseID,
		})
	}
	return out
}

// --- templates ---

var signalsTmpl = template.Must(template.New("signals").Parse(`// Code generated by go run ./cmd/humastargen; DO NOT EDIT.

package {{.Pkg}}

import (
	"github.com/joeblew999/plat-geo/internal/humastar"
	"github.com/joeblew999/plat-geo/internal/service"
)
{{range .Structs}}
var {{.Name}}SignalNames = struct {
{{- range .Fields}}
	{{.Name}} string
{{- end}}
}{
{{- range .Fields}}
	{{.Name}}: "{{.Signal}}",
{{- end}}
}

func Parse{{.Name}}Signals(s humastar.Signals) service.{{.Name}} {
	return service.{{.Name}}{
{{- range .Fields}}
	{{- if eq .GoType "string"}}
		{{.Name}}: s.String("{{.Signal}}"),
	{{- else if eq .GoType "float64"}}
		{{.Name}}: s.Float("{{.Signal}}"),
	{{- else if eq .GoType "bool"}}
		{{.Name}}: s.Bool("{{.Signal}}"),
	{{- else if eq .GoType "int"}}
		{{.Name}}: s.Int("{{.Signal}}"),
	{{- end}}
{{- end}}
	}
}

func Reset{{.Name}}Signals() map[string]any {
	return map[string]any{
{{- range .Fields}}
		"{{.Signal}}": {{.ResetGo}},
{{- end}}
	}
}
{{end}}
`))

var htmlTmpl = template.Must(template.New("html").Parse(
	`{{"{{"}}/* Code generated by go run ./cmd/humastargen; DO NOT EDIT. */{{"}}"}}
{{"{{"}}define "{{.FormTmpl}}"{{"}}"}}
{{- range .Fields}}
<div class="form-group">
{{- if eq .InputType "checkbox"}}
    <label><input type="checkbox" data-bind:{{.Signal}}> {{.Label}}</label>
{{- else if eq .InputType "sse"}}
    <label>{{.Label}}</label>
    <select data-bind:{{.Signal}}{{if .Required}} required{{end}} id="{{.SSEID}}">
        <option value="">Loading...</option>
    </select>
{{- else if eq .InputType "select"}}
    <label>{{.Label}}</label>
    <select data-bind:{{.Signal}}{{if .Required}} required{{end}}>
{{- range .Enum}}
        <option value="{{.}}">{{.}}</option>
{{- end}}
    </select>
{{- else if eq .InputType "color"}}
    <label>{{.Label}}</label>
    <div class="color-group">
        <input type="color" data-bind:{{.Signal}}>
        <input type="text" data-bind:{{.Signal}} placeholder="{{.ResetPlain}}">
    </div>
{{- else}}
    <label>{{.Label}}</label>
    <input type="{{.InputType}}" data-bind:{{.Signal}}{{if .Required}} required{{end}}{{if .Min}} min="{{.Min}}"{{end}}{{if .Max}} max="{{.Max}}"{{end}}{{if .Step}} step="{{.Step}}"{{end}}{{if .ResetPlain}} placeholder="{{.ResetPlain}}"{{end}}>
{{- end}}
</div>
{{- end}}
{{"{{"}}end{{"}}"}}
`))

type data struct {
	Name     string
	Fields   []Field
	Pkg      string // Go package name
	FormTmpl string // HTML template define name
}

type goFileData struct {
	Pkg     string
	Structs []data
}

func main() {
	// Group structs by Go output file
	goFiles := map[string]*goFileData{}
	var allData []data

	for _, s := range structs {
		d := data{
			Name:     s.Name,
			Fields:   resolve(s.Type, s.Prefix),
			Pkg:      s.GoPkg,
			FormTmpl: s.FormTmpl,
		}
		allData = append(allData, d)

		gf, ok := goFiles[s.GoOut]
		if !ok {
			gf = &goFileData{Pkg: s.GoPkg}
			goFiles[s.GoOut] = gf
		}
		gf.Structs = append(gf.Structs, d)
	}

	// Generate Go files (grouped by output path)
	var buf bytes.Buffer
	for path, gf := range goFiles {
		buf.Reset()
		if err := signalsTmpl.Execute(&buf, gf); err != nil {
			fatal("signals template for %s: %v", path, err)
		}
		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			fatal("gofmt %s: %v\n%s", path, err, buf.String())
		}
		writeFile(path, formatted)
	}

	// Generate HTML files (one per struct)
	for i, s := range structs {
		buf.Reset()
		if err := htmlTmpl.Execute(&buf, allData[i]); err != nil {
			fatal("html template for %s: %v", s.Name, err)
		}
		writeFile(s.HTMLOut, buf.Bytes())
	}
}

func writeFile(path string, d []byte) {
	if err := os.WriteFile(path, d, 0644); err != nil {
		fatal("write %s: %v", path, err)
	}
	fmt.Printf("Generated %s\n", path)
}

func fatal(f string, args ...any) {
	fmt.Fprintf(os.Stderr, f+"\n", args...)
	os.Exit(1)
}
