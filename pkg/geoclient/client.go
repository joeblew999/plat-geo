// Code generated by humaclient. DO NOT EDIT.

package geoclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// CreatedLayerBody represents the CreatedLayerBody schema
type CreatedLayerBody struct {
	ID      string      `json:"id" doc:"Generated layer ID"`
	Layer   LayerConfig `json:"layer" doc:"Created layer configuration"`
	Message string      `json:"message" doc:"Result message"`
}

// DuplicateInput represents the DuplicateInput schema
type DuplicateInput struct {
	Name string `json:"name" doc:"Name for the duplicate layer" minLength:"1" maxLength:"100"`
}

// ErrorDetail represents the ErrorDetail schema
type ErrorDetail struct {
	Location string `json:"location,omitempty" doc:"Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'"`
	Message  string `json:"message,omitempty" doc:"Error message text"`
	Value    any    `json:"value,omitempty" doc:"The value at the given location"`
}

// ErrorModel represents the ErrorModel schema
type ErrorModel struct {
	Detail   string        `json:"detail,omitempty" doc:"A human-readable explanation specific to this occurrence of the problem." example:"Property foo is required but is missing."`
	Errors   []ErrorDetail `json:"errors,omitempty" doc:"Optional list of individual error details"`
	Instance string        `json:"instance,omitempty" doc:"A URI reference that identifies the specific occurrence of the problem." format:"uri" example:"https://example.com/error-log/abc123"`
	Status   int64         `json:"status,omitempty" doc:"HTTP status code" format:"int64" example:"400"`
	Title    string        `json:"title,omitempty" doc:"A short, human-readable summary of the problem type. This value should not change between occurrences of the error." example:"Bad Request"`
	Type     string        `json:"type,omitempty" doc:"A URI reference to human-readable documentation for the error." default:"about:blank" format:"uri" example:"https://example.com/errors/example"`
}

// HealthBody represents the HealthBody schema
type HealthBody struct {
	Status  string `json:"status" doc:"Health status" example:"ok"`
	Version string `json:"version" doc:"API version" example:"1.0.0"`
}

// InfoBody represents the InfoBody schema
type InfoBody struct {
	DataDir  string   `json:"data_dir" doc:"Data directory path"`
	Db       bool     `json:"db" doc:"Whether database is available"`
	Features []string `json:"features" doc:"Available features"`
	Name     string   `json:"name" doc:"Service name"`
	Version  string   `json:"version" doc:"Service version"`
}

// JSONPatchOp represents the JsonPatchOp schema
type JSONPatchOp struct {
	From  string `json:"from,omitempty" doc:"JSON Pointer for the source of a move or copy"`
	Op    string `json:"op" doc:"Operation name" enum:"add,remove,replace,move,copy,test"`
	Path  string `json:"path" doc:"JSON Pointer to the field being operated on, or the destination of a move/copy operation"`
	Value any    `json:"value,omitempty" doc:"The value to set"`
}

// LayerBody represents the LayerBody schema
type LayerBody struct {
	DefaultVisible bool         `json:"defaultVisible" doc:"Whether layer is visible by default" default:"true" example:"true"`
	File           string       `json:"file" doc:"Source file name" example:"buildings.pmtiles"`
	Fill           string       `json:"fill,omitempty" doc:"Fill color (CSS)" default:"#3388ff" example:"#3388ff"`
	GeomType       string       `json:"geomType" doc:"Geometry type" enum:"polygon,line,point" default:"polygon" example:"polygon"`
	ID             string       `json:"id,omitempty" doc:"Unique layer identifier" example:"buildings"`
	Legend         []LegendItem `json:"legend,omitempty" doc:"Legend entries for this layer"`
	Name           string       `json:"name" doc:"Display name" minLength:"1" maxLength:"100" example:"Buildings"`
	Opacity        float64      `json:"opacity,omitempty" doc:"Layer opacity (0-1)" minimum:"0" maximum:"1" default:"0.7" format:"double" example:"0.7"`
	PmtilesLayer   string       `json:"pmtilesLayer,omitempty" doc:"Layer name within PMTiles" default:"default" example:"buildings"`
	Published      bool         `json:"published" doc:"Whether layer is published" default:"false"`
	RenderRules    []RenderRule `json:"renderRules,omitempty" doc:"Conditional styling rules"`
	Stroke         string       `json:"stroke,omitempty" doc:"Stroke color (CSS)" default:"#2266cc" example:"#2266cc"`
	Styles         []Style      `json:"styles,omitempty" doc:"Named style variants"`
}

// LayerConfig represents the LayerConfig schema
type LayerConfig struct {
	DefaultVisible bool         `json:"defaultVisible" doc:"Whether layer is visible by default" default:"true" example:"true"`
	File           string       `json:"file" doc:"Source file name" example:"buildings.pmtiles"`
	Fill           string       `json:"fill,omitempty" doc:"Fill color (CSS)" default:"#3388ff" example:"#3388ff"`
	GeomType       string       `json:"geomType" doc:"Geometry type" enum:"polygon,line,point" default:"polygon" example:"polygon"`
	ID             string       `json:"id,omitempty" doc:"Unique layer identifier" example:"buildings"`
	Legend         []LegendItem `json:"legend,omitempty" doc:"Legend entries for this layer"`
	Name           string       `json:"name" doc:"Display name" minLength:"1" maxLength:"100" example:"Buildings"`
	Opacity        float64      `json:"opacity,omitempty" doc:"Layer opacity (0-1)" minimum:"0" maximum:"1" default:"0.7" format:"double" example:"0.7"`
	PmtilesLayer   string       `json:"pmtilesLayer,omitempty" doc:"Layer name within PMTiles" default:"default" example:"buildings"`
	Published      bool         `json:"published" doc:"Whether layer is published" default:"false"`
	RenderRules    []RenderRule `json:"renderRules,omitempty" doc:"Conditional styling rules"`
	Stroke         string       `json:"stroke,omitempty" doc:"Stroke color (CSS)" default:"#2266cc" example:"#2266cc"`
	Styles         []Style      `json:"styles,omitempty" doc:"Named style variants"`
}

// LegendItem represents the LegendItem schema
type LegendItem struct {
	Color string `json:"color" doc:"Legend color (CSS)"`
	Label string `json:"label" doc:"Legend label"`
}

// MessageBody represents the MessageBody schema
type MessageBody struct {
	Message string `json:"message" doc:"Result message"`
}

// PageBodySourceFile represents the PageBodySourceFile schema
type PageBodySourceFile struct {
	Data   []SourceFile `json:"data" doc:"Items"`
	Limit  int64        `json:"limit" doc:"Page size" format:"int64"`
	Offset int64        `json:"offset" doc:"Current offset" format:"int64"`
	Total  int64        `json:"total" doc:"Total number of items" format:"int64"`
}

// PageBodyTileFile represents the PageBodyTileFile schema
type PageBodyTileFile struct {
	Data   []TileFile `json:"data" doc:"Items"`
	Limit  int64      `json:"limit" doc:"Page size" format:"int64"`
	Offset int64      `json:"offset" doc:"Current offset" format:"int64"`
	Total  int64      `json:"total" doc:"Total number of items" format:"int64"`
}

// PostAPIV1QueryRequest represents the Post-api-v1-queryRequest schema
type PostAPIV1QueryRequest struct {
	Query string `json:"query" doc:"SQL query to execute"`
}

// QueryBody represents the QueryBody schema
type QueryBody struct {
	Columns []string         `json:"columns" doc:"Column names"`
	Count   int64            `json:"count" doc:"Number of rows returned" format:"int64"`
	Rows    []map[string]any `json:"rows" doc:"Query results"`
}

// RenderRule represents the RenderRule schema
type RenderRule struct {
	Fill        string  `json:"fill" doc:"Fill color (CSS)"`
	FilterProp  string  `json:"filterProp,omitempty" doc:"Property name to filter on"`
	FilterValue string  `json:"filterValue,omitempty" doc:"Value to match"`
	Opacity     float64 `json:"opacity,omitempty" doc:"Opacity (0-1)" format:"double"`
	Radius      float64 `json:"radius,omitempty" doc:"Point radius" format:"double"`
	Stroke      string  `json:"stroke,omitempty" doc:"Stroke color (CSS)"`
	Width       float64 `json:"width,omitempty" doc:"Line width" format:"double"`
}

// SourceFile represents the SourceFile schema
type SourceFile struct {
	FileType string `json:"fileType" doc:"File type: GeoJSON or GeoParquet" example:"GeoJSON"`
	Name     string `json:"name" doc:"File name" example:"buildings.geojson"`
	Size     string `json:"size" doc:"Human-readable file size" example:"1.2 MB"`
}

// Style represents the Style schema
type Style struct {
	Fill    string  `json:"fill,omitempty" doc:"Fill color (CSS)" default:"#3388ff"`
	Name    string  `json:"name" doc:"Style name" minLength:"1" maxLength:"50"`
	Opacity float64 `json:"opacity,omitempty" doc:"Opacity (0-1)" minimum:"0" maximum:"1" default:"0.7" format:"double"`
	Stroke  string  `json:"stroke,omitempty" doc:"Stroke color (CSS)" default:"#2266cc"`
}

// TablesBody represents the TablesBody schema
type TablesBody struct {
	Tables []string `json:"tables" doc:"List of table names"`
}

// TileFile represents the TileFile schema
type TileFile struct {
	Name string `json:"name" doc:"PMTiles file name" example:"buildings.pmtiles"`
	Size string `json:"size" doc:"Human-readable file size" example:"5.4 MB"`
}

// Option is a functional option for customizing requests
type Option func(*RequestOptions)

// OptionsApplier is an interface for operation-specific options
type OptionsApplier interface {
	Apply(*RequestOptions)
}

// RequestOptions contains optional parameters for API requests
type RequestOptions struct {
	CustomHeaders map[string]string
	CustomQuery   map[string]string
	Body          any
}

// applyQueryParams applies custom query parameters to a URL
func (r *RequestOptions) applyQueryParams(u *url.URL) {
	if len(r.CustomQuery) > 0 {
		q := u.Query()
		for key, value := range r.CustomQuery {
			q.Set(key, value)
		}
		u.RawQuery = q.Encode()
	}
}

// applyHeaders applies custom headers to an HTTP request
func (r *RequestOptions) applyHeaders(req *http.Request) {
	for key, value := range r.CustomHeaders {
		req.Header.Set(key, value)
	}
}

// Functional options for customizing requests
func WithHeader(key, value string) Option {
	return func(opts *RequestOptions) {
		if opts.CustomHeaders == nil {
			opts.CustomHeaders = make(map[string]string)
		}
		opts.CustomHeaders[key] = value
	}
}

func WithQuery(key, value string) Option {
	return func(opts *RequestOptions) {
		if opts.CustomQuery == nil {
			opts.CustomQuery = make(map[string]string)
		}
		opts.CustomQuery[key] = value
	}
}

func WithBody(body any) Option {
	return func(opts *RequestOptions) {
		opts.Body = body
	}
}

// WithOptions applies operation-specific optional parameters
func WithOptions(applier OptionsApplier) Option {
	return func(opts *RequestOptions) {
		applier.Apply(opts)
	}
}

// GetAPIV1SourcesOptions contains optional parameters for GetAPIV1Sources
type GetAPIV1SourcesOptions struct {
	Limit  int64 `json:"limit,omitempty"`
	Offset int64 `json:"offset,omitempty"`
}

// Apply implements OptionsApplier for GetAPIV1SourcesOptions
func (o GetAPIV1SourcesOptions) Apply(opts *RequestOptions) {
	if o.Limit != 0 {
		if opts.CustomQuery == nil {
			opts.CustomQuery = make(map[string]string)
		}
		opts.CustomQuery["limit"] = fmt.Sprintf("%v", o.Limit)
	}
	if o.Offset != 0 {
		if opts.CustomQuery == nil {
			opts.CustomQuery = make(map[string]string)
		}
		opts.CustomQuery["offset"] = fmt.Sprintf("%v", o.Offset)
	}
}

// PlatGeoAPIClient defines the interface for the API client
type PlatGeoAPIClient interface {
	GetAPIV1EditorEvents(ctx context.Context, opts ...Option) (*http.Response, error)
	GetAPIV1EditorLayers(ctx context.Context, opts ...Option) (*http.Response, error)
	PostAPIV1EditorLayers(ctx context.Context, opts ...Option) (*http.Response, error)
	DeleteAPIV1EditorLayersByID(ctx context.Context, id string, opts ...Option) (*http.Response, error)
	GetAPIV1EditorSources(ctx context.Context, opts ...Option) (*http.Response, error)
	GetAPIV1EditorSourcesSelect(ctx context.Context, opts ...Option) (*http.Response, error)
	PostAPIV1EditorSourcesUpload(ctx context.Context, opts ...Option) (*http.Response, error)
	DeleteAPIV1EditorSourcesByFilename(ctx context.Context, filename string, opts ...Option) (*http.Response, error)
	GetAPIV1EditorTiles(ctx context.Context, opts ...Option) (*http.Response, error)
	PostAPIV1EditorTilesGenerate(ctx context.Context, opts ...Option) (*http.Response, error)
	GetAPIV1EditorTilesSelect(ctx context.Context, opts ...Option) (*http.Response, error)
	GetAPIV1Info(ctx context.Context, opts ...Option) (*http.Response, InfoBody, error)
	GetAPIV1Layers(ctx context.Context, opts ...Option) (*http.Response, map[string]any, error)
	PostAPIV1Layers(ctx context.Context, body LayerConfig, opts ...Option) (*http.Response, CreatedLayerBody, error)
	GetAPIV1LayersByID(ctx context.Context, id string, opts ...Option) (*http.Response, LayerBody, error)
	PutAPIV1LayersByID(ctx context.Context, id string, body LayerConfig, opts ...Option) (*http.Response, LayerBody, error)
	DeleteAPIV1LayersByID(ctx context.Context, id string, opts ...Option) (*http.Response, MessageBody, error)
	PatchAPIV1LayersByID(ctx context.Context, id string, opts ...Option) (*http.Response, LayerBody, error)
	PostAPIV1LayersByIDDuplicate(ctx context.Context, id string, body DuplicateInput, opts ...Option) (*http.Response, CreatedLayerBody, error)
	PostAPIV1LayersByIDPublish(ctx context.Context, id string, opts ...Option) (*http.Response, LayerBody, error)
	ListAPIV1LayersByIDStyles(ctx context.Context, id string, opts ...Option) (*http.Response, []Style, error)
	PostAPIV1LayersByIDStyles(ctx context.Context, id string, body Style, opts ...Option) (*http.Response, Style, error)
	DeleteAPIV1LayersByIDStylesByStyleID(ctx context.Context, id string, styleID string, opts ...Option) (*http.Response, MessageBody, error)
	PostAPIV1LayersByIDUnpublish(ctx context.Context, id string, opts ...Option) (*http.Response, LayerBody, error)
	PostAPIV1Query(ctx context.Context, body PostAPIV1QueryRequest, opts ...Option) (*http.Response, QueryBody, error)
	GetAPIV1Sources(ctx context.Context, opts ...Option) (*http.Response, PageBodySourceFile, error)
	GetAPIV1Tables(ctx context.Context, opts ...Option) (*http.Response, TablesBody, error)
	GetAPIV1Tiles(ctx context.Context, opts ...Option) (*http.Response, PageBodyTileFile, error)
	GetHealth(ctx context.Context, opts ...Option) (*http.Response, HealthBody, error)
	Follow(ctx context.Context, link string, result any, opts ...Option) (*http.Response, error)
}

// PlatGeoAPIClientImpl implements the PlatGeoAPIClient interface
type PlatGeoAPIClientImpl struct {
	baseURL    string
	httpClient *http.Client
}

// New creates a new PlatGeoAPIClient with default HTTP client
func New(baseURL string) PlatGeoAPIClient {
	return NewWithClient(baseURL, nil)
}

// NewWithClient creates a new PlatGeoAPIClient with custom base URL and HTTP client
func NewWithClient(baseURL string, client *http.Client) PlatGeoAPIClient {
	if client == nil {
		client = &http.Client{}
	}
	return &PlatGeoAPIClientImpl{
		baseURL:    baseURL,
		httpClient: client,
	}
}

// GetAPIV1EditorEvents calls the GET /api/v1/editor/events endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1EditorEvents(ctx context.Context, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/events"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// GetAPIV1EditorLayers calls the GET /api/v1/editor/layers endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1EditorLayers(ctx context.Context, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/layers"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// PostAPIV1EditorLayers calls the POST /api/v1/editor/layers endpoint
func (c *PlatGeoAPIClientImpl) PostAPIV1EditorLayers(ctx context.Context, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/layers"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// DeleteAPIV1EditorLayersByID calls the DELETE /api/v1/editor/layers/{id} endpoint
func (c *PlatGeoAPIClientImpl) DeleteAPIV1EditorLayersByID(ctx context.Context, id string, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/layers/{id}"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// GetAPIV1EditorSources calls the GET /api/v1/editor/sources endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1EditorSources(ctx context.Context, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/sources"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// GetAPIV1EditorSourcesSelect calls the GET /api/v1/editor/sources/select endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1EditorSourcesSelect(ctx context.Context, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/sources/select"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// PostAPIV1EditorSourcesUpload calls the POST /api/v1/editor/sources/upload endpoint
func (c *PlatGeoAPIClientImpl) PostAPIV1EditorSourcesUpload(ctx context.Context, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/sources/upload"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// DeleteAPIV1EditorSourcesByFilename calls the DELETE /api/v1/editor/sources/{filename} endpoint
func (c *PlatGeoAPIClientImpl) DeleteAPIV1EditorSourcesByFilename(ctx context.Context, filename string, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/sources/{filename}"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{filename}", url.PathEscape(filename))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// GetAPIV1EditorTiles calls the GET /api/v1/editor/tiles endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1EditorTiles(ctx context.Context, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/tiles"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// PostAPIV1EditorTilesGenerate calls the POST /api/v1/editor/tiles/generate endpoint
func (c *PlatGeoAPIClientImpl) PostAPIV1EditorTilesGenerate(ctx context.Context, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/tiles/generate"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// GetAPIV1EditorTilesSelect calls the GET /api/v1/editor/tiles/select endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1EditorTilesSelect(ctx context.Context, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/editor/tiles/select"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	return resp, nil
}

// GetAPIV1Info calls the GET /api/v1/info endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1Info(ctx context.Context, opts ...Option) (*http.Response, InfoBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/info"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, InfoBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, InfoBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, InfoBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, InfoBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result InfoBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, InfoBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// GetAPIV1Layers calls the GET /api/v1/layers endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1Layers(ctx context.Context, opts ...Option) (*http.Response, map[string]any, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, nil, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// PostAPIV1Layers calls the POST /api/v1/layers endpoint
func (c *PlatGeoAPIClientImpl) PostAPIV1Layers(ctx context.Context, body LayerConfig, opts ...Option) (*http.Response, CreatedLayerBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, CreatedLayerBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader
	jsonData, err := json.Marshal(body)
	if err != nil {
		return nil, CreatedLayerBody{}, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(jsonData)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBody)
	if err != nil {
		return nil, CreatedLayerBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	if reqBody != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, CreatedLayerBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, CreatedLayerBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result CreatedLayerBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, CreatedLayerBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// GetAPIV1LayersByID calls the GET /api/v1/layers/{id} endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1LayersByID(ctx context.Context, id string, opts ...Option) (*http.Response, LayerBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers/{id}"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, LayerBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result LayerBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, LayerBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// PutAPIV1LayersByID calls the PUT /api/v1/layers/{id} endpoint
func (c *PlatGeoAPIClientImpl) PutAPIV1LayersByID(ctx context.Context, id string, body LayerConfig, opts ...Option) (*http.Response, LayerBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers/{id}"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader
	jsonData, err := json.Marshal(body)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(jsonData)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PUT", u.String(), reqBody)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	if reqBody != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, LayerBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result LayerBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, LayerBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// DeleteAPIV1LayersByID calls the DELETE /api/v1/layers/{id} endpoint
func (c *PlatGeoAPIClientImpl) DeleteAPIV1LayersByID(ctx context.Context, id string, opts ...Option) (*http.Response, MessageBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers/{id}"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, MessageBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), reqBody)
	if err != nil {
		return nil, MessageBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, MessageBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, MessageBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result MessageBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, MessageBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// PatchAPIV1LayersByID calls the PATCH /api/v1/layers/{id} endpoint
func (c *PlatGeoAPIClientImpl) PatchAPIV1LayersByID(ctx context.Context, id string, opts ...Option) (*http.Response, LayerBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers/{id}"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PATCH", u.String(), reqBody)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, LayerBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result LayerBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, LayerBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// PostAPIV1LayersByIDDuplicate calls the POST /api/v1/layers/{id}/duplicate endpoint
func (c *PlatGeoAPIClientImpl) PostAPIV1LayersByIDDuplicate(ctx context.Context, id string, body DuplicateInput, opts ...Option) (*http.Response, CreatedLayerBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers/{id}/duplicate"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, CreatedLayerBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader
	jsonData, err := json.Marshal(body)
	if err != nil {
		return nil, CreatedLayerBody{}, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(jsonData)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBody)
	if err != nil {
		return nil, CreatedLayerBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	if reqBody != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, CreatedLayerBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, CreatedLayerBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result CreatedLayerBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, CreatedLayerBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// PostAPIV1LayersByIDPublish calls the POST /api/v1/layers/{id}/publish endpoint
func (c *PlatGeoAPIClientImpl) PostAPIV1LayersByIDPublish(ctx context.Context, id string, opts ...Option) (*http.Response, LayerBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers/{id}/publish"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBody)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, LayerBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result LayerBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, LayerBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// ListAPIV1LayersByIDStyles calls the GET /api/v1/layers/{id}/styles endpoint
func (c *PlatGeoAPIClientImpl) ListAPIV1LayersByIDStyles(ctx context.Context, id string, opts ...Option) (*http.Response, []Style, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers/{id}/styles"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, nil, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result []Style
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// PostAPIV1LayersByIDStyles calls the POST /api/v1/layers/{id}/styles endpoint
func (c *PlatGeoAPIClientImpl) PostAPIV1LayersByIDStyles(ctx context.Context, id string, body Style, opts ...Option) (*http.Response, Style, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers/{id}/styles"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, Style{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader
	jsonData, err := json.Marshal(body)
	if err != nil {
		return nil, Style{}, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(jsonData)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBody)
	if err != nil {
		return nil, Style{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	if reqBody != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, Style{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, Style{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result Style
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, Style{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// DeleteAPIV1LayersByIDStylesByStyleID calls the DELETE /api/v1/layers/{id}/styles/{styleId} endpoint
func (c *PlatGeoAPIClientImpl) DeleteAPIV1LayersByIDStylesByStyleID(ctx context.Context, id string, styleID string, opts ...Option) (*http.Response, MessageBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers/{id}/styles/{styleId}"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))
	pathTemplate = strings.ReplaceAll(pathTemplate, "{styleId}", url.PathEscape(styleID))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, MessageBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), reqBody)
	if err != nil {
		return nil, MessageBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, MessageBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, MessageBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result MessageBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, MessageBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// PostAPIV1LayersByIDUnpublish calls the POST /api/v1/layers/{id}/unpublish endpoint
func (c *PlatGeoAPIClientImpl) PostAPIV1LayersByIDUnpublish(ctx context.Context, id string, opts ...Option) (*http.Response, LayerBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/layers/{id}/unpublish"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBody)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, LayerBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, LayerBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result LayerBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, LayerBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// PostAPIV1Query calls the POST /api/v1/query endpoint
func (c *PlatGeoAPIClientImpl) PostAPIV1Query(ctx context.Context, body PostAPIV1QueryRequest, opts ...Option) (*http.Response, QueryBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/query"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, QueryBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader
	jsonData, err := json.Marshal(body)
	if err != nil {
		return nil, QueryBody{}, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(jsonData)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBody)
	if err != nil {
		return nil, QueryBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	if reqBody != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, QueryBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, QueryBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result QueryBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, QueryBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// GetAPIV1Sources calls the GET /api/v1/sources endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1Sources(ctx context.Context, opts ...Option) (*http.Response, PageBodySourceFile, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/sources"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, PageBodySourceFile{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, PageBodySourceFile{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, PageBodySourceFile{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, PageBodySourceFile{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result PageBodySourceFile
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, PageBodySourceFile{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// GetAPIV1Tables calls the GET /api/v1/tables endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1Tables(ctx context.Context, opts ...Option) (*http.Response, TablesBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/tables"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, TablesBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, TablesBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, TablesBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, TablesBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result TablesBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, TablesBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// GetAPIV1Tiles calls the GET /api/v1/tiles endpoint
func (c *PlatGeoAPIClientImpl) GetAPIV1Tiles(ctx context.Context, opts ...Option) (*http.Response, PageBodyTileFile, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/api/v1/tiles"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, PageBodyTileFile{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, PageBodyTileFile{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, PageBodyTileFile{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, PageBodyTileFile{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result PageBodyTileFile
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, PageBodyTileFile{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// GetHealth calls the GET /health endpoint
func (c *PlatGeoAPIClientImpl) GetHealth(ctx context.Context, opts ...Option) (*http.Response, HealthBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/health"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, HealthBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, HealthBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, HealthBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, HealthBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result HealthBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, HealthBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// Follow follows a link to retrieve a related resource
func (c *PlatGeoAPIClientImpl) Follow(ctx context.Context, link string, result any, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Parse the link URL
	u, err := url.Parse(link)
	if err != nil {
		return nil, fmt.Errorf("invalid link URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body if provided
	var reqBody io.Reader
	if reqOpts.Body != nil {
		jsonData, err := json.Marshal(reqOpts.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal request body: %w", err)
		}
		reqBody = bytes.NewReader(jsonData)
	}

	// Create request (assume GET unless body is provided)
	method := "GET"
	if reqBody != nil {
		method = "POST"
	}

	req, err := http.NewRequestWithContext(ctx, method, u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	if reqBody != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	// Parse response body into provided result type
	if err := json.NewDecoder(resp.Body).Decode(result); err != nil {
		return resp, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, nil
}

// parseLinkHeader parses a Link header and returns the URL for the specified relation
func parseLinkHeader(linkHeader, rel string) string {
	// Simple parser for Link header format: <url>; rel="next", <url2>; rel="prev"
	links := strings.Split(linkHeader, ",")
	for _, link := range links {
		link = strings.TrimSpace(link)
		parts := strings.Split(link, ";")
		if len(parts) < 2 {
			continue
		}

		url := strings.Trim(strings.TrimSpace(parts[0]), "<>")

		for _, param := range parts[1:] {
			param = strings.TrimSpace(param)
			if strings.Contains(param, "rel=") {
				// Extract rel value (handle both quoted and unquoted)
				relValue := strings.TrimPrefix(param, "rel=")
				relValue = strings.Trim(relValue, "\"'")
				if relValue == rel {
					return url
				}
			}
		}
	}
	return ""
}
