// Command signals generates Datastar signal helpers from struct definitions.
//
// Usage:
//
//	go run ./internal/gen/signals
//
// This generates internal/api/editor/signals_gen.go with type-safe
// signal parsing and reset functions for Huma + Datastar integration.
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"reflect"
	"strings"
	"text/template"

	"github.com/joeblew999/plat-geo/internal/service"
)

// SignalConfig defines how to generate signals for a struct.
type SignalConfig struct {
	StructName   string            // e.g., "LayerConfig"
	Prefix       string            // e.g., "newlayer" -> newlayername, newlayerfile
	Type         reflect.Type      // The actual type
	SkipFields   []string          // Fields to skip (e.g., ID, complex types)
	ResetValues  map[string]string // Custom reset values (field -> value)
	SignalNames  map[string]string // Override signal names (field -> signal name suffix)
}

var configs = []SignalConfig{
	{
		StructName: "LayerConfig",
		Prefix:     "newlayer",
		Type:       reflect.TypeOf(service.LayerConfig{}),
		SkipFields: []string{"ID", "RenderRules", "Legend"},
		ResetValues: map[string]string{
			"PMTilesLayer":   `"default"`,
			"GeomType":       `"polygon"`,
			"Fill":           `"#3388ff"`,
			"Stroke":         `"#2266cc"`,
			"Opacity":        `0.7`,
			"DefaultVisible": `true`,
		},
		SignalNames: map[string]string{
			"DefaultVisible": "visible", // HTML uses newlayervisible, not newlayerdefaultvisible
		},
	},
}

const tmpl = `// Code generated by go run ./internal/gen/signals; DO NOT EDIT.

package editor

import (
	"github.com/joeblew999/plat-geo/internal/service"
)

{{range .Configs}}
// --- {{.StructName}} Signal Helpers ---

// {{.StructName}}SignalNames contains all Datastar signal names for {{.StructName}}.
// Use these constants in HTML templates: data-bind:{{"{{"}}{{.StructName}}SignalNames.Name{{"}}"}}
var {{.StructName}}SignalNames = struct {
{{- range .Fields}}
	{{.FieldName}} string
{{- end}}
}{
{{- range .Fields}}
	{{.FieldName}}: "{{.SignalName}}",
{{- end}}
}

// Parse{{.StructName}}Signals extracts a {{.StructName}} from Datastar signals.
func Parse{{.StructName}}Signals(s Signals) service.{{.StructName}} {
	return service.{{.StructName}}{
{{- range .Fields}}
	{{- if eq .GoType "string"}}
		{{.FieldName}}: s.String("{{.SignalName}}"),
	{{- else if eq .GoType "float64"}}
		{{.FieldName}}: s.Float("{{.SignalName}}"),
	{{- else if eq .GoType "bool"}}
		{{.FieldName}}: s.Bool("{{.SignalName}}"),
	{{- else if eq .GoType "int"}}
		{{.FieldName}}: s.Int("{{.SignalName}}"),
	{{- end}}
{{- end}}
	}
}

// Reset{{.StructName}}Signals returns signals to reset the {{.StructName}} form.
func Reset{{.StructName}}Signals() map[string]any {
	return map[string]any{
{{- range .Fields}}
		"{{.SignalName}}": {{.ResetValue}},
{{- end}}
	}
}

{{end}}
`

type FieldInfo struct {
	FieldName  string
	SignalName string
	GoType     string
	ResetValue string
}

type ConfigData struct {
	StructName string
	Fields     []FieldInfo
}

type TemplateData struct {
	Configs []ConfigData
}

func main() {
	var data TemplateData

	for _, cfg := range configs {
		skipSet := make(map[string]bool)
		for _, s := range cfg.SkipFields {
			skipSet[s] = true
		}

		var fields []FieldInfo
		t := cfg.Type

		for i := 0; i < t.NumField(); i++ {
			field := t.Field(i)

			if skipSet[field.Name] {
				continue
			}

			goType := field.Type.Kind().String()
			if goType == "float32" {
				goType = "float64"
			}

			// Only handle primitive types
			if goType != "string" && goType != "float64" && goType != "bool" && goType != "int" {
				continue
			}

			// Signal name: prefix + lowercase field name (or override)
			suffix := strings.ToLower(field.Name)
			if override, ok := cfg.SignalNames[field.Name]; ok {
				suffix = override
			}
			signalName := cfg.Prefix + suffix

			// Default reset values by type
			resetValue := `""`
			switch goType {
			case "float64":
				resetValue = "0"
			case "bool":
				resetValue = "false"
			case "int":
				resetValue = "0"
			}

			// Custom reset value if specified
			if custom, ok := cfg.ResetValues[field.Name]; ok {
				resetValue = custom
			}

			fields = append(fields, FieldInfo{
				FieldName:  field.Name,
				SignalName: signalName,
				GoType:     goType,
				ResetValue: resetValue,
			})
		}

		data.Configs = append(data.Configs, ConfigData{
			StructName: cfg.StructName,
			Fields:     fields,
		})
	}

	t := template.Must(template.New("signals").Parse(tmpl))
	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		fmt.Fprintf(os.Stderr, "template error: %v\n", err)
		os.Exit(1)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "format error: %v\n%s\n", err, buf.String())
		os.Exit(1)
	}

	outPath := "internal/api/editor/signals_gen.go"
	if err := os.WriteFile(outPath, formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "write error: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s\n", outPath)
}
