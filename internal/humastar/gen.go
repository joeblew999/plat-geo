// gen.go — Compile-time codegen: OpenAPI schemas → Go signal parsers.
//
// Called by `go run ./cmd/geo gen-datastar`. Walks the Huma schema registry
// (not JSON files) and generates signals_gen.go with:
//   - ParseXxxSignals()  — type-safe signal → struct mapping
//   - ResetXxxSignals()  — default signal values for form init
//   - XxxSignalNames     — signal name constants
//
// Input: Huma API + DatastarSchemaConfig (reflect.Type for field names,
// schema properties for types/defaults/extensions).
// Output: Go source files (one per unique GoOut path).
package humastar

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"
	"text/template"

	"github.com/danielgtaylor/huma/v2"
)

// GenerateSignals walks the Huma schema registry and generates Go signal
// parsers for schemas that have x-datastar extensions.
// Uses the Go reflect.Type for field names and the Huma schema for metadata
// (types, defaults, enums, extensions). No JSON parsing, no re-walking struct tags.
func GenerateSignals(api huma.API, configs []DatastarSchemaConfig) error {
	schemas := api.OpenAPI().Components.Schemas.Map()

	type field struct {
		Name    string // Go field name
		Signal  string // Datastar signal name
		GoType  string // Go type string
		ResetGo string // Go literal for reset value
	}
	type genData struct {
		Name   string
		Fields []field
	}
	type goFileData struct {
		Pkg     string
		Structs []genData
	}

	goFiles := map[string]*goFileData{}

	for _, cfg := range configs {
		name := cfg.Type.Name()
		schema, ok := schemas[name]
		if !ok {
			return fmt.Errorf("schema %q not found in OpenAPI spec", name)
		}

		ds, ok := schema.Extensions["x-datastar"]
		if !ok {
			return fmt.Errorf("schema %q missing x-datastar extension", name)
		}
		dsMeta, ok := ds.(DatastarSchema)
		if !ok {
			return fmt.Errorf("schema %q x-datastar extension has wrong type", name)
		}

		var fields []field

		// Walk Go struct fields for names, use Huma schema for metadata
		t := cfg.Type
		for i := range t.NumField() {
			sf := t.Field(i)

			// Get JSON name
			jsonName := sf.Tag.Get("json")
			if idx := strings.IndexByte(jsonName, ','); idx >= 0 {
				jsonName = jsonName[:idx]
			}
			if jsonName == "" || jsonName == "-" {
				continue
			}

			// Find property in Huma schema
			prop, ok := schema.Properties[jsonName]
			if !ok {
				continue
			}

			// Skip non-primitive (arrays, objects)
			goType := humaTypeToGo(prop.Type)
			if goType == "" {
				continue
			}

			// Skip ID
			if sf.Name == "ID" {
				continue
			}

			// Signal name: prefix + (x-signal override or lowercase json name)
			suffix := strings.ToLower(jsonName)
			if sig, ok := prop.Extensions["x-signal"]; ok {
				suffix = fmt.Sprint(sig)
			}
			signal := dsMeta.Prefix + suffix

			// Reset value from schema default
			resetGo := goZero(goType)
			if prop.Default != nil {
				resetGo = goLiteral(prop.Default, goType)
			}

			fields = append(fields, field{
				Name:    sf.Name,
				Signal:  signal,
				GoType:  goType,
				ResetGo: resetGo,
			})
		}

		gf, ok := goFiles[cfg.GoOut]
		if !ok {
			gf = &goFileData{Pkg: cfg.GoPkg}
			goFiles[cfg.GoOut] = gf
		}
		gf.Structs = append(gf.Structs, genData{Name: name, Fields: fields})
	}

	// Generate Go files
	var buf bytes.Buffer
	for path, gf := range goFiles {
		buf.Reset()
		if err := signalsGenTmpl.Execute(&buf, gf); err != nil {
			return fmt.Errorf("template for %s: %w", path, err)
		}
		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			return fmt.Errorf("gofmt %s: %w\n%s", path, err, buf.String())
		}
		if err := os.WriteFile(path, formatted, 0644); err != nil {
			return fmt.Errorf("write %s: %w", path, err)
		}
		fmt.Printf("Generated %s\n", path)
	}

	return nil
}

func humaTypeToGo(typ string) string {
	switch typ {
	case "string":
		return "string"
	case "number":
		return "float64"
	case "integer":
		return "int"
	case "boolean":
		return "bool"
	default:
		return ""
	}
}

func goZero(goType string) string {
	switch goType {
	case "float64", "int":
		return "0"
	case "bool":
		return "false"
	default:
		return `""`
	}
}

func goLiteral(v any, goType string) string {
	switch goType {
	case "string":
		return fmt.Sprintf("%q", fmt.Sprint(v))
	default:
		return fmt.Sprint(v)
	}
}

var signalsGenTmpl = template.Must(template.New("signals").Parse(`// Code generated by geo gen-datastar; DO NOT EDIT.

package {{.Pkg}}

import (
	"github.com/joeblew999/plat-geo/internal/humastar"
	"github.com/joeblew999/plat-geo/internal/service"
)
{{range .Structs}}
var {{.Name}}SignalNames = struct {
{{- range .Fields}}
	{{.Name}} string
{{- end}}
}{
{{- range .Fields}}
	{{.Name}}: "{{.Signal}}",
{{- end}}
}

func Parse{{.Name}}Signals(s humastar.Signals) service.{{.Name}} {
	return service.{{.Name}}{
{{- range .Fields}}
	{{- if eq .GoType "string"}}
		{{.Name}}: s.String("{{.Signal}}"),
	{{- else if eq .GoType "float64"}}
		{{.Name}}: s.Float("{{.Signal}}"),
	{{- else if eq .GoType "bool"}}
		{{.Name}}: s.Bool("{{.Signal}}"),
	{{- else if eq .GoType "int"}}
		{{.Name}}: s.Int("{{.Signal}}"),
	{{- end}}
{{- end}}
	}
}

func Reset{{.Name}}Signals() map[string]any {
	return map[string]any{
{{- range .Fields}}
		"{{.Signal}}": {{.ResetGo}},
{{- end}}
	}
}
{{end}}
`))
